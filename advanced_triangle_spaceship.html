<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Alien UFO - Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ffff;
            z-index: 100;
            font-size: 14px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #00ffff;
            z-index: 100;
            font-size: 12px;
            text-shadow: 0 0 10px #00ffff;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info">
            <h3>Advanced Alien UFO</h3>
            <p>FPS: <span id="fps">0</span></p>
            <p>Triangles: <span id="triangles">0</span></p>
        </div>
        <div id="controls">
            <p>Controls:</p>
            <p>Mouse: Rotate Camera</p>
            <p>Scroll: Zoom</p>
            <p>WASD: Move Ship</p>
            <p>Space: Boost</p>
            <p>Click: Fire Lasers</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Scene setup
        let scene, camera, renderer, controls;
        let spaceship, spaceshipGroup;
        let stars, nebula;
        let engineParticles = [];
        let time = 0;
        let frameCount = 0;
        let lastTime = performance.now();
        
        // Movement variables
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, boost = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        
        // Game objects
        let asteroids = [];
        let spaceStations = [];
        let lasers = [];
        let explosions = [];
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        
        // Shader materials
        let spaceshipMaterial, engineMaterial, shieldMaterial, asteroidMaterial, stationMaterial;
        
        init();
        animate();
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000011, 0.0008);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 5, 15);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000011, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 100;
            controls.minDistance = 5;
            
            // Lighting
            setupLighting();
            
            // Space background
            createSpaceBackground();
            
            // Create spaceship
            createSpaceship();
            
            // Create asteroids and space stations
            createAsteroids();
            createSpaceStations();
            
            // Event listeners
            setupEventListeners();
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            // Main directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            
            // Blue accent light
            const blueLight = new THREE.PointLight(0x0088ff, 2, 100);
            blueLight.position.set(-20, 10, 20);
            scene.add(blueLight);
            
            // Red accent light
            const redLight = new THREE.PointLight(0xff4400, 1.5, 80);
            redLight.position.set(20, -10, -20);
            scene.add(redLight);
        }
        
        function createSpaceBackground() {
            // Starfield
            const starsGeometry = new THREE.BufferGeometry();
            const starsCount = 10000;
            const positions = new Float32Array(starsCount * 3);
            const colors = new Float32Array(starsCount * 3);
            
            for (let i = 0; i < starsCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 2000;
                positions[i + 1] = (Math.random() - 0.5) * 2000;
                positions[i + 2] = (Math.random() - 0.5) * 2000;
                
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.55, Math.random() * 0.25 + 0.55);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }
            
            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const starsMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
            
            // Nebula background
            const nebulaGeometry = new THREE.SphereGeometry(500, 32, 32);
            const nebulaMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color1: { value: new THREE.Color(0x000033) },
                    color2: { value: new THREE.Color(0x000066) },
                    color3: { value: new THREE.Color(0x330066) }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color1;
                    uniform vec3 color2;
                    uniform vec3 color3;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    float noise(vec3 p) {
                        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
                    }
                    
                    void main() {
                        vec3 pos = vPosition * 0.01 + time * 0.1;
                        float n1 = noise(pos);
                        float n2 = noise(pos * 2.0);
                        float n3 = noise(pos * 4.0);
                        
                        float pattern = n1 * 0.5 + n2 * 0.3 + n3 * 0.2;
                        
                        vec3 color = mix(color1, color2, pattern);
                        color = mix(color, color3, pattern * 0.5);
                        
                        gl_FragColor = vec4(color, 0.3);
                    }
                `,
                side: THREE.BackSide,
                transparent: true
            });
            
            nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
            scene.add(nebula);
        }
        
        function createSpaceship() {
            spaceshipGroup = new THREE.Group();
            
            // Advanced UFO hull shader material
            spaceshipMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    baseColor: { value: new THREE.Color(0x1a1a2e) },
                    accentColor: { value: new THREE.Color(0x00ffaa) },
                    metallic: { value: 0.9 },
                    roughness: { value: 0.1 },
                    emissive: { value: new THREE.Color(0x002244) }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    varying vec3 vWorldPosition;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        vUv = uv;
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 baseColor;
                    uniform vec3 accentColor;
                    uniform float metallic;
                    uniform float roughness;
                    uniform vec3 emissive;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    varying vec3 vWorldPosition;
                    
                    float noise(vec3 p) {
                        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
                    }
                    
                    float fbm(vec3 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        for (int i = 0; i < 4; i++) {
                            value += amplitude * noise(p);
                            p *= 2.0;
                            amplitude *= 0.5;
                        }
                        return value;
                    }
                    
                    void main() {
                        vec3 normal = normalize(vNormal);
                        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
                        
                        // Complex alien patterns
                        float pattern1 = sin(vUv.x * 15.0 + time) * sin(vUv.y * 15.0 + time * 1.3);
                        float pattern2 = fbm(vPosition * 2.0 + time * 0.5);
                        
                        // Hexagonal panels
                        vec2 hexUv = vUv * 10.0;
                        float hexPattern = abs(sin(hexUv.x * 3.14159)) * abs(sin(hexUv.y * 3.14159 * 0.866));
                        hexPattern = step(0.7, hexPattern);
                        
                        // Energy circuits
                        float circuits = step(0.9, fract(vUv.x * 20.0)) + step(0.9, fract(vUv.y * 20.0));
                        circuits *= sin(time * 3.0) * 0.5 + 0.5;
                        
                        // Fresnel effect
                        float fresnel = pow(1.0 - dot(normal, viewDir), 3.0);
                        
                        vec3 color = baseColor;
                        color = mix(color, accentColor, pattern1 * 0.3);
                        color = mix(color, accentColor * 1.5, hexPattern * 0.4);
                        color += accentColor * circuits * 0.8;
                        color += emissive * fresnel;
                        color += accentColor * fresnel * 0.5;
                        color *= (1.0 + pattern2 * 0.2);
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });
            
            // Main UFO hull (circular design)
            const mainHullGeometry = new THREE.CylinderGeometry(4, 6, 1.5, 32, 1);
            const mainHull = new THREE.Mesh(mainHullGeometry, spaceshipMaterial);
            mainHull.castShadow = true;
            mainHull.receiveShadow = true;
            spaceshipGroup.add(mainHull);
            
            // Upper dome
            const domeGeometry = new THREE.SphereGeometry(3, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const dome = new THREE.Mesh(domeGeometry, spaceshipMaterial);
            dome.position.y = 0.75;
            dome.castShadow = true;
            spaceshipGroup.add(dome);
            
            // Lower hull
            const lowerHullGeometry = new THREE.SphereGeometry(5, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
            const lowerHull = new THREE.Mesh(lowerHullGeometry, spaceshipMaterial);
            lowerHull.position.y = -0.75;
            lowerHull.castShadow = true;
            spaceshipGroup.add(lowerHull);
            
            // Cockpit dome
            const cockpitGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const cockpitMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x001155,
                transparent: true,
                opacity: 0.6,
                roughness: 0.05,
                metalness: 0.95,
                clearcoat: 1.0,
                clearcoatRoughness: 0.05,
                transmission: 0.3
            });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 2, 0);
            cockpit.castShadow = true;
            spaceshipGroup.add(cockpit);
            
            // Landing gear/supports
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const supportGeometry = new THREE.CylinderGeometry(0.1, 0.2, 2, 8);
                const supportMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x444444,
                    roughness: 0.2,
                    metalness: 0.9
                });
                const support = new THREE.Mesh(supportGeometry, supportMaterial);
                support.position.set(Math.cos(angle) * 4, -1.5, Math.sin(angle) * 4);
                support.castShadow = true;
                spaceshipGroup.add(support);
            }
            
            // Engine systems
            createUFOEngines();
            
            // Weapon systems
            createUFOWeapons();
            
            // Shield effect
            createShield();
            
            // Details and alien tech
            addUFODetails();
            
            scene.add(spaceshipGroup);
            spaceship = spaceshipGroup;
        }
        
        function createUFOEngines() {
            engineMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    intensity: { value: 1.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float intensity;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 center = vec2(0.5, 0.5);
                        float dist = distance(vUv, center);
                        
                        float flame = 1.0 - smoothstep(0.0, 0.5, dist);
                        flame *= sin(time * 10.0 + dist * 20.0) * 0.3 + 0.7;
                        
                        vec3 color = mix(vec3(0.0, 0.3, 1.0), vec3(1.0, 0.5, 0.0), flame);
                        color *= intensity;
                        
                        gl_FragColor = vec4(color, flame);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            // Circular engine array
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const engineGeometry = new THREE.CylinderGeometry(0.2, 0.4, 1, 8);
                const engine = new THREE.Mesh(engineGeometry, engineMaterial);
                engine.position.set(Math.cos(angle) * 3.5, -1, Math.sin(angle) * 3.5);
                spaceshipGroup.add(engine);
            }
            
            // Central main engine
            const mainEngineGeometry = new THREE.CylinderGeometry(0.5, 0.8, 1.5, 12);
            const mainEngine = new THREE.Mesh(mainEngineGeometry, engineMaterial);
            mainEngine.position.set(0, -1.5, 0);
            spaceshipGroup.add(mainEngine);
        }
        
        function createUFOWeapons() {
            // Weapon turrets around the perimeter
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                
                // Weapon base
                const baseGeometry = new THREE.SphereGeometry(0.3, 12, 12);
                const baseMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x666666,
                    roughness: 0.1,
                    metalness: 0.9
                });
                const weaponBase = new THREE.Mesh(baseGeometry, baseMaterial);
                weaponBase.position.set(Math.cos(angle) * 4, 0, Math.sin(angle) * 4);
                spaceshipGroup.add(weaponBase);
                
                // Weapon barrel
                const barrelGeometry = new THREE.CylinderGeometry(0.08, 0.12, 1.5, 8);
                const barrelMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x888888,
                    roughness: 0.1,
                    metalness: 0.95
                });
                const weaponBarrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                weaponBarrel.position.set(Math.cos(angle) * 4.5, 0.2, Math.sin(angle) * 4.5);
                weaponBarrel.lookAt(new THREE.Vector3(Math.cos(angle) * 10, 0, Math.sin(angle) * 10));
                weaponBarrel.userData = { isWeapon: true, angle: angle };
                spaceshipGroup.add(weaponBarrel);
            }
        }
        
        function createShield() {
            shieldMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 0.3 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        float fresnel = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        
                        float pattern = sin(vPosition.x * 5.0 + time) * 
                                       sin(vPosition.y * 5.0 + time * 1.3) * 
                                       sin(vPosition.z * 5.0 + time * 0.7);
                        
                        vec3 color = vec3(0.0, 0.8, 1.0);
                        float alpha = (fresnel + pattern * 0.3) * opacity;
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            
            const shieldGeometry = new THREE.SphereGeometry(5, 32, 32);
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            spaceshipGroup.add(shield);
        }
        
        function addUFODetails() {
            // Central antenna array
            for (let i = 0; i < 3; i++) {
                const antennaGeometry = new THREE.CylinderGeometry(0.02, 0.05, 3 + i, 8);
                const antennaMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xaaaaaa,
                    roughness: 0.1,
                    metalness: 1.0
                });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.set(Math.sin(i * 2) * 0.5, 3.5 + i * 0.5, Math.cos(i * 2) * 0.5);
                spaceshipGroup.add(antenna);
            }
            
            // Perimeter lights
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const lightGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const lightMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL((i / 16) * 0.3 + 0.5, 1.0, 0.7),
                    emissive: new THREE.Color().setHSL((i / 16) * 0.3 + 0.5, 1.0, 0.5),
                    emissiveIntensity: 0.8
                });
                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                light.position.set(Math.cos(angle) * 5.5, 0, Math.sin(angle) * 5.5);
                spaceshipGroup.add(light);
            }
            
            // Alien tech details
            for (let i = 0; i < 30; i++) {
                const shapes = [
                    new THREE.OctahedronGeometry(Math.random() * 0.3 + 0.1),
                    new THREE.TetrahedronGeometry(Math.random() * 0.3 + 0.1),
                    new THREE.IcosahedronGeometry(Math.random() * 0.3 + 0.1)
                ];
                const detailGeometry = shapes[Math.floor(Math.random() * shapes.length)];
                const detailMaterial = new THREE.MeshPhysicalMaterial({
                    color: new THREE.Color().setHSL(Math.random() * 0.3 + 0.4, 0.8, 0.4),
                    roughness: Math.random() * 0.3 + 0.1,
                    metalness: Math.random() * 0.5 + 0.5,
                    emissive: new THREE.Color().setHSL(Math.random() * 0.3 + 0.4, 0.8, 0.2),
                    emissiveIntensity: 0.3
                });
                const detail = new THREE.Mesh(detailGeometry, detailMaterial);
                const radius = Math.random() * 4 + 2;
                const angle = Math.random() * Math.PI * 2;
                detail.position.set(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * 2,
                    Math.sin(angle) * radius
                );
                detail.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                detail.castShadow = true;
                spaceshipGroup.add(detail);
            }
        }
        
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize, false);
            
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
        }
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': boost = true; event.preventDefault(); break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'Space': boost = false; break;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateMovement() {
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();
            
            const speed = boost ? 0.5 : 0.2;
            
            if (moveForward || moveBackward) velocity.z -= direction.z * speed;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed;
            
            spaceship.translateX(velocity.x);
            spaceship.translateZ(velocity.z);
            
            velocity.multiplyScalar(0.95);
            
            // Engine intensity based on movement
            if (engineMaterial) {
                const intensity = Math.max(Math.abs(velocity.z), Math.abs(velocity.x)) * 5 + 0.5;
                engineMaterial.uniforms.intensity.value = boost ? intensity * 2 : intensity;
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.016;
            frameCount++;
            
            // Update FPS counter
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                document.getElementById('fps').textContent = frameCount;
                document.getElementById('triangles').textContent = renderer.info.render.triangles;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            // Update movement
            updateMovement();
            
            // Update shader uniforms
            if (spaceshipMaterial) {
                spaceshipMaterial.uniforms.time.value = time;
            }
            if (engineMaterial) {
                engineMaterial.uniforms.time.value = time;
            }
            if (shieldMaterial) {
                shieldMaterial.uniforms.time.value = time;
            }
            if (nebula) {
                nebula.material.uniforms.time.value = time * 0.1;
            }
            
            // Rotate spaceship slightly
            if (spaceship) {
                spaceship.rotation.y += 0.005;
                spaceship.rotation.x = Math.sin(time * 0.5) * 0.1;
                spaceship.rotation.z = Math.sin(time * 0.3) * 0.05;
            }
            
            // Rotate stars
            if (stars) {
                stars.rotation.y += 0.0002;
            }
            
            // Update controls
            controls.update();
            
            // Render
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>